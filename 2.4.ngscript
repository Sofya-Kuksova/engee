using Plots

# Общие константы
pi_val = π              # Число пи (π) в Julia встроено как π
a = 2/3                 # для экспоненциального затухания во втором слагаемом f(t)
b = 2/3                 # частота для затухающей синусоиды и косинусоиды в f(t)
c = pi_val/20           # частота для незатухающей синусоиды и косинусоиды

# Константы для разложения на простейшие дроби (приблизительные значения)
A = -1.686
B = 1.093
C_val = 1.686
D = 1.155

# Предварительный расчёт коэффициента для синусного слагаемого затухающей части:
term_coef = (D - a * C_val) / b

# Функция heaviside для скалярного значения (будет использоваться с broadcasting)
heaviside(x) = x >= 0 ? 1.0 : 0.0

# Определение основной функции f(t) для u₂(t)
function f(t)
    # Здесь t может быть как скаляром, так и вектором; используем поэлементные операции (broadcasting)
    term1 = A * cos.(c .* t)
    term2 = (B / c) * sin.(c .* t)
    term3 = C_val * exp.(-a .* t) .* cos.(b .* t)
    term4 = term_coef * exp.(-a .* t) .* sin.(b .* t)
    return term1 .+ term2 .+ term3 .+ term4
end

# Функция u₂(t) как обратное преобразование Лапласа по результату разложения на простейшие дроби
function u2(t)
    # t – вектор значений времени
    H = heaviside.(t .- 20)  # Функция Хевисайда: 0 для t < 20, 1 для t ≥ 20
    return (pi_val/45) .* (f(t) .+ f(t .- 20) .* H)
end

# Функция u₁(t) – обратное преобразование Лапласа для (pi/20)/(s²+(pi/20)²)*(1+e^(–20s))
function u1(t)
    H = heaviside.(t .- 20)
    return sin.(c .* t) .+ H .* sin.(c .* (t .- 20))
end

# Создаем вектор времени от 0 до 40 (1000 точек)
t_vals = range(0, stop=40, length=1000)

# Вычисляем значения функций u₂(t) и u₁(t)
u2_vals = u2(collect(t_vals))
u1_vals = u1(collect(t_vals))

# Построение графиков
plot(t_vals, u2_vals, color="blue", linewidth=2, label="u₂(t)", grid=true)
plot!(t_vals, u1_vals, color="red", linewidth=2, label="u₁(t)")
title!("Графики u₂(t) и u₁(t)")
xlabel!("Время t")
ylabel!("Значение функции")
xlims!(0, 40)

# Сохранение графика в файл
savefig("u_12.png")
